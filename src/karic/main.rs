extern crate kari;
extern crate byteorder;
extern crate clap;

use std::io::prelude::*;
use std::fs::File;
use byteorder::{WriteBytesExt, ReadBytesExt, BigEndian};
use clap::{Arg, App, SubCommand};

fn main() {
    let matches = App::new("karic")
        .version("0.1.0")
        .author("Benjamin Lee <benjamin.fik.lee@gmail.com>")
        .about("Compile kari programs to bytecode")
        .subcommand(SubCommand::with_name("compile")
            .arg(Arg::with_name("SOURCE")
                .help("Source file name")
                .required(true))
            .arg(Arg::with_name("OUT")
                .help("Output bytecode file name")
                .required(true))
            .arg(Arg::with_name("debug-lexer")
                .long("debug-lexer")
                .help("Print the output of the lexer"))
            .arg(Arg::with_name("AST_OUT")
                .long("output-ast")
                .takes_value(true)
                .help("Output the AST as a graphviz dot file"))
            .arg(Arg::with_name("debug-bytecode")
                .long("debug-bytecode")
                .help("Print the generated bytecode")))
        .subcommand(SubCommand::with_name("run")
            .arg(Arg::with_name("BYTECODE")
                .help("Bytecode file name")))
        .get_matches();

    if let Some(matches) = matches.subcommand_matches("compile") {
        let source_fname = matches.value_of("SOURCE").unwrap();
        let mut source = String::new();
        File::open(source_fname).ok().expect("Could not read source")
            .read_to_string(&mut source).unwrap();

        let tokens = kari::lexer::lex_source(source, Some(source_fname.to_string()));
        if matches.is_present("debug-lexer") {
            println!("{:?}", tokens.iter().map(|t| format!("{}", t.0)).collect::<Vec<String>>());
        }

        let ast = kari::parser::Parser::new(tokens).parse().unwrap();
        if let Some(fname) = matches.value_of("AST_OUT") {
            let dotgraph = ast.0.visualize_dot();
            File::create(fname).unwrap().write(&dotgraph.into_bytes()[..]).unwrap();
        }

        let bytecode = kari::compile::compile_ast(ast).unwrap();
        if matches.is_present("debug-bytecode") {
            println!("{}",
                bytecode.iter().map(|o| format!("{}", o)).collect::<Vec<String>>().join("\n"));
        }

        let out_fname = matches.value_of("OUT").unwrap();
        let mut out = File::create(out_fname).ok().expect("Could not create output file");
        out.write_u32::<BigEndian>(bytecode.len() as u32).unwrap();
        for block in bytecode.iter() {
            block.write(&mut out);
        }
    }
    else if let Some(matches) = matches.subcommand_matches("run") {
        let bc_fname = matches.value_of("BYTECODE").unwrap();
        let mut bc = File::open(bc_fname).ok().expect("Could not read bytecode");
        let n_blocks = bc.read_u32::<BigEndian>().unwrap();
        let mut bytecode = Vec::new();
        for _ in 0..n_blocks {
            let block = kari::bytecode::BytecodeBlock::read(&mut bc);
            //println!("{}", block);
            bytecode.push(block);
        }
        let mut interpreter = kari::interpreter::Interpreter::new();
        interpreter.add_blocks(bytecode);
        if let Err(err) = interpreter.run_block(kari::bytecode::BlockId(0)) {
            println!("{:?}\n{}\n{}\n{}", err,
                interpreter.traceback(),
                interpreter.format_vars(),
                interpreter.format_stack());
        }
    }
}
